#version 460 core
layout(local_size_x = 1) in;

struct Particle {
	vec4 pos;
	vec4 color;
	vec4 history[249]; 
};


layout(std430, binding = 0) buffer ParticlesBuffer {
	Particle[] particles;
};

uniform vec3 spawnPoint;
uniform float maxDisplacement;

float map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

vec3 randomPos(vec2 st) {
    return vec3(
        mod(sin(dot(st, vec2(23.456, 98.765))) * 98765.4321, 1.0),
        mod(sin(dot(st, vec2(34.567, 12.345))) * 54321.8765, 1.0),
        mod(sin(dot(st, vec2(56.789, 21.987))) * 32109.8765, 1.0)
    );
}
vec3 randomColor(vec2 st) {
    return vec3(fract(sin(dot(st, vec2(12.9898, 78.233))) * 43758.5453),
                fract(sin(dot(st, vec2(21.345, 67.567))) * 87658.231),
                fract(sin(dot(st, vec2(45.678, 93.123))) * 76545.987));
}

void main() {
	/*
	OPTIONS : 
	- if you dislike same uniform values giving same points, you can use uTime
	- if you don't like all (x,y,z) values being the same, then find an alternative
	*/
	uint index = gl_GlobalInvocationID.x;

	vec2 randInput = vec2(spawnPoint.x, spawnPoint.y) + maxDisplacement * index;
	
	vec3 randomPosOutput = randomPos(randInput);
	randomPosOutput.x = map(randomPosOutput.x, 0.0, 1.0, -maxDisplacement, maxDisplacement);
	randomPosOutput.y = map(randomPosOutput.y, 0.0, 1.0, -maxDisplacement, maxDisplacement);
	randomPosOutput.z = map(randomPosOutput.z, 0.0, 1.0, -maxDisplacement, maxDisplacement);


	particles[index].pos = vec4( randomPosOutput , 1.0);
	particles[index].color = vec4(randomColor(randInput), 1.0);
	
	for(int i = 0; i < particles[index].history.length() ; i++){
		particles[index].history[i] = particles[index].pos;
	}

}
